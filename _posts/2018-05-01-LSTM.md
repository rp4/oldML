---
layout: post
title: "Long Short Term Memory"
author: "Richard Penfil"
categories: Algorithm
tags: [Long Short Term Memory, Machine Learning]
image: lstm_head.jpg
---

Below is an example of a ltsm model built in tensorflow using the [MotionSense data](https://www.kaggle.com/malekzadeh/motionsense-dataset) from kaggle. This dataset includes time-series data generated by accelerometer and gyroscope sensors. I will focus on the accelerometer data. For more detail regarding data preparation and EDA please refer to the GC Forest Page.

# Preprocess Data


```python
N_TIME_STEPS = 200
N_FEATURES = 3
step = 20
segments = []
labels = []
for i in range(0, len(df) - N_TIME_STEPS, step):
    xs = df['userAcceleration.x'].values[i: i + N_TIME_STEPS]
    ys = df['userAcceleration.y'].values[i: i + N_TIME_STEPS]
    zs = df['userAcceleration.z'].values[i: i + N_TIME_STEPS]
    label = stats.mode(df['activity'][i: i + N_TIME_STEPS])[0][0]
    segments.append([xs, ys, zs])
    labels.append(label)
np.array(segments).shape
```




    (56177, 3, 200)




```python
reshaped_segments = np.asarray(segments, dtype= np.float32).reshape(-1, N_TIME_STEPS, N_FEATURES)
labels = np.asarray(pd.get_dummies(labels), dtype = np.float32)
reshaped_segments.shape
```




    (56177, 200, 3)




```python
labels[0]
```




    array([ 1.,  0.,  0.,  0.], dtype=float32)




```python
X_train, X_test, y_train, y_test = train_test_split(
        reshaped_segments, labels, test_size=0.1, random_state=7)
```

# LSTM Model
(2 fully-connected and 2 LSTM stacked layers with 64 units each)


```python
N_CLASSES = 4
N_HIDDEN_UNITS = 64
def create_LSTM_model(inputs):
    W = {
        'hidden': tf.Variable(tf.random_normal([N_FEATURES, N_HIDDEN_UNITS])),
        'output': tf.Variable(tf.random_normal([N_HIDDEN_UNITS, N_CLASSES]))
    }
    biases = {
        'hidden': tf.Variable(tf.random_normal([N_HIDDEN_UNITS], mean=1.0)),
        'output': tf.Variable(tf.random_normal([N_CLASSES]))
    }
    
    X = tf.transpose(inputs, [1, 0, 2])
    X = tf.reshape(X, [-1, N_FEATURES])
    hidden = tf.nn.relu(tf.matmul(X, W['hidden']) + biases['hidden'])
    hidden = tf.split(hidden, N_TIME_STEPS, 0)

    # Stack 2 LSTM layers
    lstm_layers = [tf.contrib.rnn.BasicLSTMCell(N_HIDDEN_UNITS, forget_bias=1.0) for _ in range(2)]
    lstm_layers = tf.contrib.rnn.MultiRNNCell(lstm_layers)

    outputs, _ = tf.contrib.rnn.static_rnn(lstm_layers, hidden, dtype=tf.float32)

    # Get output for the last time step
    lstm_last_output = outputs[-1]

    return tf.matmul(lstm_last_output, W['output']) + biases['output']
```


```python
#Placeholders
tf.reset_default_graph()

X = tf.placeholder(tf.float32, [None, N_TIME_STEPS, N_FEATURES], name="input")
Y = tf.placeholder(tf.float32, [None, N_CLASSES])
```


```python
pred_Y = create_LSTM_model(X)
pred_softmax = tf.nn.softmax(pred_Y, name="y_")
```


```python
#L2 regularization
L2_LOSS = 0.0015

l2 = L2_LOSS * \
    sum(tf.nn.l2_loss(tf_var) for tf_var in tf.trainable_variables())

loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits = pred_Y, labels = Y)) + l2
```


```python
#Accuracy and Optimizer
LEARNING_RATE = 0.0025
optimizer = tf.train.AdamOptimizer(learning_rate=LEARNING_RATE).minimize(loss)
correct_pred = tf.equal(tf.argmax(pred_softmax, 1), tf.argmax(Y, 1))
accuracy = tf.reduce_mean(tf.cast(correct_pred, dtype=tf.float32))
```


```python
#Train
N_EPOCHS = 50
BATCH_SIZE = 1024
saver = tf.train.Saver()

history = dict(train_loss=[], 
                     train_acc=[], 
                     test_loss=[], 
                     test_acc=[])

sess=tf.InteractiveSession()
sess.run(tf.global_variables_initializer())

train_count = len(X_train)

for i in range(1, N_EPOCHS + 1):
    for start, end in zip(range(0, train_count, BATCH_SIZE),
                          range(BATCH_SIZE, train_count + 1,BATCH_SIZE)):
        sess.run(optimizer, feed_dict={X: X_train[start:end],
                                       Y: y_train[start:end]})

    _, acc_train, loss_train = sess.run([pred_softmax, accuracy, loss], feed_dict={
                                            X: X_train, Y: y_train})

    _, acc_test, loss_test = sess.run([pred_softmax, accuracy, loss], feed_dict={
                                            X: X_test, Y: y_test})

    history['train_loss'].append(loss_train)
    history['train_acc'].append(acc_train)
    history['test_loss'].append(loss_test)
    history['test_acc'].append(acc_test)

    if i != 1 and i % 10 != 0:
        continue

    print('epoch:',i,' test accuracy:',acc_test,' loss:',loss_test)
    
predictions, acc_final, loss_final = sess.run([pred_softmax, accuracy, loss], feed_dict={X: X_test, Y: y_test})

print()
print('final results: accuracy:',acc_final,' loss:',loss_final)
```

    epoch: 1  test accuracy: 0.745283  loss: 1.14371
    epoch: 10  test accuracy: 0.875045  loss: 0.672743
    epoch: 20  test accuracy: 0.926664  loss: 0.434267
    epoch: 30  test accuracy: 0.926308  loss: 0.369008
    epoch: 40  test accuracy: 0.912246  loss: 0.353723
    epoch: 50  test accuracy: 0.975792  loss: 0.203479
    
    final results: accuracy: 0.975792  loss: 0.203479
    


```python
#Save Model
pickle.dump(predictions, open("predictions.p", "wb"))
pickle.dump(history, open("history.p", "wb"))
tf.train.write_graph(sess.graph_def, '.', './checkpoint/har.pbtxt')  
saver.save(sess, save_path = "./checkpoint/har.ckpt")
sess.close()
```


```python
#Import Model
history = pickle.load(open("history.p", "rb"))
predictions = pickle.load(open("predictions.p", "rb"))
```


```python
#Evaluate Model
plt.figure(figsize=(12, 8))
plt.plot(np.array(history['train_loss']), "r--", label="Train loss")
plt.plot(np.array(history['train_acc']), "g--", label="Train accuracy")
plt.plot(np.array(history['test_loss']), "r-", label="Test loss")
plt.plot(np.array(history['test_acc']), "g-", label="Test accuracy")
plt.title("Training session's progress over iterations")
plt.legend(loc='upper right', shadow=True)
plt.ylabel('Training Progress (Loss or Accuracy values)')
plt.xlabel('Training Epoch')
plt.ylim(0)
plt.show()
```


<a href="https://github.com/rp4/rp4.github.io/blob/master/assets/img/LSTM_files/LSTM_1.png"><img src="{{ site.github.url }}/assets/img/LSTM_files/LSTM_1.png"></a>



```python
#Confusion Matrix
LABELS = ['Jogging', 'Sitting', 'Standing', 'Walking']
max_test = np.argmax(y_test, axis=1)
max_predictions = np.argmax(predictions, axis=1)
confusion_matrix = metrics.confusion_matrix(max_test, max_predictions)
plt.figure(figsize=(16, 14))
sns.heatmap(confusion_matrix, xticklabels=LABELS, yticklabels=LABELS, annot=True, fmt="d",cmap="YlGnBu",cbar=False);
plt.title("Confusion matrix")
plt.ylabel('True label')
plt.xlabel('Predicted label')
plt.show();
```


<a href="https://github.com/rp4/rp4.github.io/blob/master/assets/img/LSTM_files/LSTM_2.png"><img src="{{ site.github.url }}/assets/img/LSTM_files/LSTM_2.png"></a>



```python
#PRECISION AND RECALL
report = sklearn.metrics.classification_report(max_test, max_predictions)
print(report)
```

                 precision    recall  f1-score   support
    
              0       1.00      0.99      1.00       676
              1       0.96      0.96      0.96      1708
              2       0.96      0.96      0.96      1590
              3       1.00      1.00      1.00      1644
    
    avg / total       0.98      0.98      0.98      5618
    
    


```python
#Export Model
from tensorflow.python.tools import freeze_graph

MODEL_NAME = 'har'

input_graph_path = 'checkpoint/' + MODEL_NAME+'.pbtxt'
checkpoint_path = './checkpoint/' +MODEL_NAME+'.ckpt'
restore_op_name = "save/restore_all"
filename_tensor_name = "save/Const:0"
output_frozen_graph_name = 'frozen_'+MODEL_NAME+'.pb'

freeze_graph.freeze_graph(input_graph_path, input_saver="",
                          input_binary=False, input_checkpoint=checkpoint_path, 
                          output_node_names="y_", restore_op_name="save/restore_all",
                          filename_tensor_name="save/Const:0", 
                          output_graph=output_frozen_graph_name, clear_devices=True, initializer_nodes="")
```

    INFO:tensorflow:Restoring parameters from ./checkpoint/har.ckpt
    INFO:tensorflow:Froze 8 variables.
    Converted 8 variables to const ops.
    6862 ops in the final graph.
    


```python

```
